\subsection{Testowanie biało\dywiz skrzynkowe}

\subsubsection{Klasa testująca \texttt{algs.network.ToStringTest}}
Klasa \texttt{algs.network.ToStringTest} zawiera testy dla metody
\texttt{algs.network.VertexStructure.toString()}.

\begin{center}
\begin{tabular}{@{} >{\bfseries}p{0.2\textwidth} @{\hspace{0.02\textwidth}} p{0.78\textwidth} @{}}
    \toprule
    TestCase & \texttt{algs.network.ToStringTest.testEmpty()} \\
    \midrule
    ID & B.1.1.1 \\
    \midrule
    Dane wejściowe & Struktura bez zdefiniowanych krawędzi wejścia/wyjścia. \\
    \midrule
    Oczekiwany wynik & "forward:List[0], backward:List[0]" \\
    \midrule
    Wykonawca & MO \\
    \bottomrule
\end{tabular}
\end{center}

\begin{center}
\begin{tabular}{@{} >{\bfseries}p{0.2\textwidth} @{\hspace{0.02\textwidth}} p{0.78\textwidth} @{}}
    \toprule
    TestCase & \texttt{algs.network.ToStringTest.testOneEdge()} \\
    \midrule
    ID & B.1.1.2 \\
    \midrule
    Dane wejściowe &
    \begin{minipage}[h]{0.78\textwidth}
    \begin{enumerate}
        \item Krawędź wyjścia (1, 2, 1).
        \item Krawędź wejścia (2, 1, 1).
    \end{enumerate}
    \end{minipage} \\
    \midrule
    Oczekiwany wynik &
    \begin{minipage}[h]{0.78\textwidth}
    \begin{enumerate}
        \item "forward:List[1]: [0] -> [1] 0/1 @ 0, backward:List[1]: [0] -> [1] 0/1 @ 0"
    \end{enumerate}
    \end{minipage} \\
    \midrule
    Wykonawca & MO \\
    \bottomrule
\end{tabular}
\end{center}

\begin{center}
\begin{tabular}{@{} >{\bfseries}p{0.2\textwidth} @{\hspace{0.02\textwidth}} p{0.78\textwidth} @{}}
    \toprule
    TestCase & \texttt{algs.network.ToStringTest.testThreeEdges()} \\
    \midrule
    ID & B.1.1.3 \\
    \midrule
    Dane wejściowe &
    \begin{minipage}[h]{0.78\textwidth}
    \begin{enumerate}
        \item Trzy krawędzie wejścia (0, 3, 1), (1, 3, 1), (2, 3, 1).
        \item Trzy krawędzie wyjścia (3, 4, 1), (3, 5, 1), (3, 6, 1).
    \end{enumerate}
    \end{minipage} \\
    \midrule
    Oczekiwany wynik &
    \begin{minipage}[h]{0.78\textwidth}
    \begin{enumerate}
        \item "forward:List[3]: [0] -> [1] 0/1 @ 0, backward:List[3]: [0] -> [1] 0/1 @ 0"
    \end{enumerate}
    \end{minipage} \\
    \midrule
    Wykonawca & MO \\
    \bottomrule
\end{tabular}
\end{center}


\subsubsection{Klasa testująca \texttt{algs.network.MinimalNetworkConstructorTest}}
Klasa \texttt{algs.network.MinimalNetworkConstructorTest} zawiera testy dla
minimalnego konstruktora
\texttt{algs.network.FlowNetworkArray(int sourceIndex, int sinkIndex, int numVertices)}.

\begin{center}
\begin{tabular}{@{} >{\bfseries}p{0.2\textwidth} @{\hspace{0.02\textwidth}} p{0.78\textwidth} @{}}
    \toprule
    TestCase & \texttt{algs.network.MinimalNetworkConstructorTest.validArgumentTest()} \\
    \midrule
    ID & B.1.2.1 \\
    \midrule
    Opis & Konstruktor minimalnej struktury sieci. Inicjalizuje tylko niezbędne zmienne. \\
    \midrule
    Dane wejściowe & \texttt{sourceIndex = 0; sinkIndex = 1; numVertices = 2;} \\
    \midrule
    Oczekiwany wynik & \texttt{sourceIndex = 0; sinkIndex = 1; numVertices = 2;} \\
    \midrule
    Wykonawca & MO \\
    \bottomrule
\end{tabular}
\end{center}

\begin{center}
\begin{tabular}{@{} >{\bfseries}p{0.2\textwidth} @{\hspace{0.02\textwidth}} p{0.78\textwidth} @{}}
    \toprule
    TestCase & \texttt{algs.network.MinimalNetworkConstructorTest.invalidArgumentsTest()} \\
    \midrule
    ID & B.1.2.2 \\
    \midrule
    Opis & Konstruktor minimalnej struktury sieci. Inicjalizuje tylko niezbędne zmienne. \\
    \midrule
    Dane wejściowe & \texttt{sourceIndex = -1; sinkIndex = -2; numVertices = -2;} \\
    \midrule
    Oczekiwany wynik & IllegalArgumentException \\
    \midrule
    Wykonawca & MO \\
    \bottomrule
\end{tabular}
\end{center}

\begin{center}
\begin{tabular}{@{} >{\bfseries}p{0.2\textwidth} @{\hspace{0.02\textwidth}} p{0.78\textwidth} @{}}
    \toprule
    TestCase & \texttt{algs.network.MinimalNetworkConstructorTest.sinkBeforeSourceTest()} \\
    \midrule
    ID & B.1.2.3 \\
    \midrule
    Opis & Konstruktor minimalnej struktury sieci. Inicjalizuje tylko niezbedne zmienne. \\
    \midrule
    Dane wejściowe & \texttt{sourceIndex = 1; sinkIndex = 0; numVertices = 2;} \\
    \midrule
    Oczekiwany wynik & \texttt{IllegalArgumentException} \\
    \midrule
    Wykonawca & MO \\
    \bottomrule
\end{tabular}
\end{center}

\begin{center}
\begin{tabular}{@{} >{\bfseries}p{0.2\textwidth} @{\hspace{0.02\textwidth}} p{0.78\textwidth} @{}}
    \toprule
    TestCase & \texttt{algs.network.MinimalNetworkConstructorTest.tooFewVerticesTest()} \\
    \midrule
    ID & B.1.2.4 \\
    \midrule
    Opis & Konstruktor minimalnej struktury sieci. Inicjalizuje tylko niezbedne zmienne. \\
    \midrule
    Dane wejściowe & \texttt{sourceIndex = 0; sinkIndex = 7; numVertices = 2;} \\
    \midrule
    Oczekiwany wynik & \texttt{IllegalArgumentException} \\
    \midrule
    Wykonawca & MO \\
    \bottomrule
\end{tabular}
\end{center}


\subsubsection{Klasa testująca \texttt{algs.network.NetworkConstructorTest}}
Klasa \texttt{algs.network.MinimalNetworkConstructorTest} zawiera testy dla
konstruktora
\texttt{algs.network.FlowNetworkArray(int numVertices, int sourceIndex, int sinkIndex, Iterator<EdgeInfo> edges)}.

\begin{center}
\begin{tabular}{@{} >{\bfseries}p{0.2\textwidth} @{\hspace{0.02\textwidth}} p{0.78\textwidth} @{}}
    \toprule
    TestCase & \texttt{algs.network.NetworkConstructorTest.validArgumentsTest()} \\
    \midrule
    ID & B.1.3.1 \\
    \midrule
    Opis & Konstruktor struktury reprezentującej graf przepływu. \\
    \midrule
    Dane wejściowe & \texttt{numVertices = 4; sourceIndex = 0; sinkIndex = 3; edges = \{(0, 1, 3); (1, 2, 2); (2, 3, 2); (0, 2, 3)\};} \\
    \midrule
    Oczekiwany wynik & \texttt{numVertices = 4; sourceIndex = 0; sinkIndex = 3; edges = \{(0, 1, 3); (1, 2, 2); (2, 3, 2); (0, 2, 3)\};} \\
    \midrule
    Wykonawca & MO \\
    \bottomrule
\end{tabular}
\end{center}

\begin{center}
\begin{tabular}{@{} >{\bfseries}p{0.2\textwidth} @{\hspace{0.02\textwidth}} p{0.78\textwidth} @{}}
    \toprule
    TestCase & \texttt{algs.network.NetworkConstructorTest.invalidNumVerticesTest()} \\
    \midrule
    ID & B.1.3.2 \\
    \midrule
    Opis & Konstruktor struktury reprezentującej graf przepływu. \\
    \midrule
    Dane wejściowe & \texttt{numVertices = -4; sourceIndex = 0; sinkIndex = 3; edges = \{(0, 1, 3); (1, 2, 2); (2, 3, 2); (0, 2, 3)\};} \\
    \midrule
    Oczekiwany wynik & \texttt{IllegalArgumentException} \\
    \midrule
    Wykonawca & MO \\
    \bottomrule
\end{tabular}
\end{center}

\begin{center}
\begin{tabular}{@{} >{\bfseries}p{0.2\textwidth} @{\hspace{0.02\textwidth}} p{0.78\textwidth} @{}}
    \toprule
    TestCase & \texttt{algs.network.NetworkConstructorTest.invalidSourceIndexTest()} \\
    \midrule
    ID & B.1.3.3 \\
    \midrule
    Opis & Konstruktor struktury reprezentującej graf przepływu. \\
    \midrule
    Dane wejściowe & \texttt{numVertices = 4; sourceIndex = -1; sinkIndex = 3; edges = \{(0, 1, 3); (1, 2, 2); (2, 3, 2); (0, 2, 3)\};} \\
    \midrule
    Oczekiwany wynik & \texttt{IllegalArgumentException} \\
    \midrule
    Wykonawca & MO \\
    \bottomrule
\end{tabular}
\end{center}

\begin{center}
\begin{tabular}{@{} >{\bfseries}p{0.2\textwidth} @{\hspace{0.02\textwidth}} p{0.78\textwidth} @{}}
    \toprule
    TestCase & \texttt{algs.network.NetworkConstructorTest.invalidSinkIndexTest()} \\
    \midrule
    ID & B.1.3.4 \\
    \midrule
    Opis & Konstruktor struktury reprezentującej graf przepływu. \\
    \midrule
    Dane wejściowe & \texttt{numVertices = 4; sourceIndex = 0; sinkIndex = -3; edges = \{(0, 1, 3); (1, 2, 2); (2, 3, 2); (0, 2, 3)\};} \\
    \midrule
    Oczekiwany wynik & \texttt{IllegalArgumentException} \\
    \midrule
    Wykonawca & MO \\
    \bottomrule
\end{tabular}
\end{center}

\begin{center}
\begin{tabular}{@{} >{\bfseries}p{0.2\textwidth} @{\hspace{0.02\textwidth}} p{0.78\textwidth} @{}}
    \toprule
    TestCase & \texttt{algs.network.NetworkConstructorTest.tooFewVerticesTest()} \\
    \midrule
    ID & B.1.3.5 \\
    \midrule
    Opis & Konstruktor struktury reprezentującej graf przepływu. \\
    \midrule
    Dane wejściowe & \texttt{numVertices = 2; sourceIndex = 0; sinkIndex = 3; edges = \{(0, 1, 3); (1, 2, 2); (2, 3, 2); (0, 2, 3)\};} \\
    \midrule
    Oczekiwany wynik & \texttt{IllegalArgumentException} \\
    \midrule
    Wykonawca & MO \\
    \bottomrule
\end{tabular}
\end{center}

\begin{center}
\begin{tabular}{@{} >{\bfseries}p{0.2\textwidth} @{\hspace{0.02\textwidth}} p{0.78\textwidth} @{}}
    \toprule
    TestCase & \texttt{algs.network.NetworkConstructorTest.sinkBeforeSourceTest()} \\
    \midrule
    ID & B.1.3.6 \\
    \midrule
    Opis & Konstruktor struktury reprezentującej graf przepływu. \\
    \midrule
    Dane wejściowe & \texttt{numVertices = 4; sourceIndex = 3; sinkIndex = 0; edges = \{(0, 1, 3);(1, 2, 2); (2, 3, 2); (0, 2, 3)\};} \\
    \midrule
    Oczekiwany wynik & \texttt{IllegalArgumentException} \\
    \midrule
    Wykonawca & MO \\
    \bottomrule
\end{tabular}
\end{center}

\begin{center}
\begin{tabular}{@{} >{\bfseries}p{0.2\textwidth} @{\hspace{0.02\textwidth}} p{0.78\textwidth} @{}}
    \toprule
    TestCase & \texttt{algs.network.NetworkConstructorTest.sinkBeforeSourceTest()} \\
    \midrule
    ID & B.1.3.7 \\
    \midrule
    Opis & Konstruktor struktury reprezentującej graf przepływu. \\
    \midrule
    Dane wejściowe & \texttt{numVertices = 4; sourceIndex = 0; sinkIndex = 3; edges = pusty Iterator} \\
    \midrule
    Oczekiwany wynik & \texttt{numVertices = 4; sourceIndex = 0; sinkIndex = 3; edges = pusta tablica EdgeInfo[4][4]} \\
    \midrule
    Wykonawca & MO \\
    \bottomrule
\end{tabular}
\end{center}


\subsubsection{Klasa testująca \texttt{algs.network.IllegalStateExceptionTest}}
Klasa \texttt{algs.network.IllegalStateExceptionTest} zawiera testy weryfikujące
poprawne wywoływanie wyjątków przez metodę
\texttt{algs.network.FlowNetworkArray.validate()}.

\begin{center}
\begin{tabular}{@{} >{\bfseries}p{0.2\textwidth} @{\hspace{0.02\textwidth}} p{0.78\textwidth} @{}}
    \toprule
    TestCase & \texttt{algs.network.IllegalStateExceptionTest.moreFlowThanCapacityTest()} \\
    \midrule
    ID & B.1.4.1 \\
    \midrule
    Opis &
    \begin{minipage}[h]{0.78\textwidth}
    Metoda weryfikuje czy informacje na temat sieci są akceptowalne. Zwracany
    jest wyjątek, \texttt{IllegalStateException} w dwóch przypadkach:
    \begin{enumerate}
        \item Przepływ krawędzi jest większy niż przepustowość.
        \item Liczba krawędzi wchodzących jest różna od liczby krawędzi wychodzących.
    \end{enumerate}
    \end{minipage} \\
    \midrule
    Dane wejściowe & Krawędź (1, 2, 1), przepływ = 2 \\
    \midrule
    Oczekiwany wynik & \texttt{IllegalStateException} \\
    \midrule
    Wykonawca & MO \\
    \bottomrule
\end{tabular}
\end{center}

\begin{center}
\begin{tabular}{@{} >{\bfseries}p{0.2\textwidth} @{\hspace{0.02\textwidth}} p{0.78\textwidth} @{}}
    \toprule
    TestCase & \texttt{algs.network.IllegalStateExceptionTest.flowConservationTest()} \\
    \midrule
    ID & B.1.4.2 \\
    \midrule
    Opis &
    \begin{minipage}[h]{0.78\textwidth}
    Metoda weryfikuje czy informacje na temat sieci są akceptowalne. Zwracany
    jest wyjątek, \texttt{IllegalStateException} w dwóch przypadkach:
    \begin{enumerate}
        \item Przepływ krawędzi jest większy niż przepustowość.
        \item Liczba krawędzi wchodzących jest różna od liczby krawędzi wychodzących.
    \end{enumerate}
    \end{minipage} \\
    \midrule
    Dane wejściowe & Krawędź (1, 2, 1), przepływ = 2 \\
    \midrule
    Oczekiwany wynik & Krawędź (1, 2, 1), przepływ = 1 \\
    \midrule
    Wykonawca & MO \\
    \bottomrule
\end{tabular}
\end{center}
